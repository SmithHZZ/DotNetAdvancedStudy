using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _07_designpatternprinciple
{
    /// <summary>
    /// 设计模式原则
    /// 
    /// 1、单一职责原则
    /// ---------------------------------------------------------------------
    /// 功能的拆分力度，让每个类只做一件事
    /// 
    /// 如果类型简单  方法不多可以违背单一职责原则
    /// 
    /// 如果类型复杂，方法繁多，建议进行拆分，遵循单一职责原则
    /// 
    /// ---------------------------------------------------------------------
    /// 2、里氏替换原则
    /// ---------------------------------------------------------------------
    /// 
    /// 任何使用基类的地方都可以透明的使用其子类
    /// 
    /// （1）父类有的，子类必须有
    ///     如果基类出现了子类没有的东西，就应该断掉继承
    ///     （再来一个父类，只包含所需的东西）
    /// （2）子类可以有自己的属性和行为
    ///     子类出现的地方，父类不一定能代替
    /// （3）父类实现的东西，子类就不要再写了，就是不要（new 隐藏）
    ///     如果想修改父类的行为，可以通过abstract/virtual来实现
    /// 
    /// 指导如何使用继承
    /// 
    /// 声明属性、字段、变量时尽量声明为父类，更灵活，右侧可以“随意”替换（父类能满足的情况下）
    /// 
    /// ---------------------------------------------------------------------
    /// 3、依赖倒置原则
    /// ---------------------------------------------------------------------
    /// 高层模块不应该依赖低层模块，二者应该通过抽象来依赖
    /// 
    /// 依赖抽象而不是依赖细节
    /// 
    /// 抽象：接口、抽象类
    /// 
    /// 细节：普通类型 一切都是确定的
    /// 
    /// 面向抽象编程：尽量使用抽象类或者接口
    /// 
    /// 无法解决特殊功能的问题，需要直接使用子类，面向抽象用的就是通用功能，
    /// 
    /// 
    /// 面向抽象就是为了通用功能设计的
    /// 
    /// 
    /// 面向抽象：只要抽象不变，高层就不变
    /// 
    /// 
    /// 
    /// 细节是多变的（需求经常变化）
    /// 如果高层直接依赖细节，那么细节的变化，会引起高层的变化，层数多了，
    /// 很小的改动就会引起很大的工作
    /// 
    /// 依赖倒置原则（理论基础） IOC 控制反转（实践封装） DI依赖注入（实现IOC的手段）
    /// 
    /// 
    /// ---------------------------------------------------------------------
    /// 4、接口隔离原则
    /// ---------------------------------------------------------------------
    /// 客户端不应该依赖他不需要的接口，
    /// 一个类对另一个类的依赖应该建立在最小接口上
    /// 
    /// 不适合放在抽象类，但是面向抽象编程
    /// 如果其他功能需要扩展，可以使用接口继续扩展
    /// 
    /// 拆分接口
    /// 
    /// 1、不能是大而全
    /// 2、也不能太小（每个方法一个接口）
    /// 3、接口合并
    /// 
    /// 
    /// ---------------------------------------------------------------------
    /// 5、迪米特法则（最少知道原则）
    /// ---------------------------------------------------------------------
    /// 一个对象应该对其他对象保持最少的了解
    /// 只与直接的朋友通信
    /// 
    /// 高内聚，低耦合
    /// 
    /// 类与类之间的关系：
    /// 纵向：继承≈实现（最密切）
    /// 横向：聚合>组合>关联>依赖（出现在方法内部）
    /// 
    /// 降低类与类之间的耦合
    /// 
    /// 
    /// 只与直接的朋友通信，避免依赖更多的类型
    /// 
    /// 基类库中的类除外
    /// 
    /// 门面模式：上层只和门面层交互，门面层和下面各个子系统进行交互
    /// 
    /// 
    /// 三层架构：为什么分层 UI->BLL->DAL，减少依赖
    /// 
    /// 
    /// 指导原则：
    /// 
    /// 去掉内部依赖，降低访问修饰符
    /// 
    /// 1、依赖别人更少
    /// 2、让别人知道更少（使用私有修饰，降低访问权限）
    /// 
    /// 
    /// ---------------------------------------------------------------------
    /// 6、开闭原则
    /// ---------------------------------------------------------------------
    /// 
    /// 对扩展开放，对修改关闭
    /// 
    /// 修改：修改现有代码
    /// 
    /// 扩展：增加代码（类）
    /// 
    /// 面向对象的基本单位是类
    /// 
    /// 面向对象语言是一种静态语言，最害怕变化，会波及较多内容，全面测试
    /// 
    /// 
    /// 准则，也是面向对象开发的终极目标
    /// 
    /// ---------------------------------------------------------------------
    /// 
    /// 
    /// 
    /// 
    /// 
    /// 
    /// 
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {

        }
    }
}
